## 实验目的：广播的使用
注册广播的方式一般有两种--在代码中注册和在AndroidManifest.xml中注册。其中前者为动态注册，后者为静态注册  
###动态注册
广播接收器--新建一个类，让它继承BroadReceive，并重写父类的onReceive()方法，  
动态注册的广播接收器一定要取消注册，在onDestroy()方法中通过调用unregisterReceive()方法来实现

    @Override
    protected void onDestroy(){
        super.onDestroy();
        //unregisterReceiver(networkChangeReceiver);

	}

	class NetworkChangeReceiver extends BroadcastReceiver{
        @Override
        public void onReceive(Context context, Intent intent){
           // Toast.makeText(context,"network changes",Toast.LENGTH_SHORT).show();

            ConnectivityManager connectivityManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
            NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
            if(networkInfo != null && networkInfo.isAvailable() ){
                Toast.makeText(context,"network is available",Toast.LENGTH_SHORT).show();
            }
            else{
                Toast.makeText(context,"network is unavailable", Toast.LENGTH_SHORT).show();
            }
        }
    }

运行程序，在注册完成时会收到一条广播，按Home键，打开设置，进入Data usage，点击Moblie data按钮来启动网络和禁用网络，Toast会提醒你网络的变化情况  
![网络可用](/BroadcastTest/img/捕获.PNG)  
![网络不可用](/BroadcastTest/img/捕获1.PNG)  

## 静态注册
静态的广播接收器一定要在AndroidManifest.xml文件中完成，所有的静态广播接收器都是在<receiver>中进行注册，另外监听系统广播也需要生声明权限  
 
        <receiver
            android:name=".BootCompleteReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
         </receiver>

##发送自定义广播
广播主要分为两种类型：标准广播和有序广播

###标准广播
标准广播是一种完全异步执行的广播，在广播发送出去之后，所有广播接收器几乎都在同一时间接收到这条广播消息  
在发送标准广播前，先定义一个广播接收器来接收广播消息———这里使用静态注册 ，如上  
在xml文件注册时，使MyBroadcastTest接收一条广播，等一会发送广播时，能接收到这条广播  

            <intent-filter>
                <action android:name="com.example.broadcasttest.MY_BROADCAST"/>
            </intent-filter>

在布局文件中添加一个按钮，用于发送广播的触发点，构造一个Intent对象，并把要发送的广播的值传入，，然后调用context的sendBroadcast()方法将广播发送出去，这样，所有监听这条广播的接收器都会收到消息  
![标准广播](/BroadcastTest/img/捕获3.PNG)  

广播是一种可以跨进程的通信方式，我们在应用程序发出广播，其他应用程序也会收得到  
新建一个项目，并用静态注册一个广播接收器，接收的同样是上面那条广播。运行这个项目，再返回到BroadcastTest项目的主界面，点击按钮，就会分别弹出两次提示消息  
![标准广播](/BroadcastTest/img/捕获3.PNG)  
![标准广播](/BroadcastTest/img/捕获4.PNG)

### 有序广播
有序广播是一种同步执行的广播，在广播发出后，同一时刻只会有一个广播接收器能收到这条广播消息  
发送有序广播只需改动一行代码，将sendBroadcast()方法改成sebdOrderBroadcast()方法，再将设置广播接收器的先后顺序

			<intent-filter  android:priority="100">
                <action android:name="com.example.broadcasttest.MY_BROADCAST"/>
            </intent-filter>


			sendOrderedBroadcast(intent,null);

在重新运行程序时，点击按钮，只有一个Toast消息能够弹出  
![标准广播](/BroadcastTest/img/捕获3.PNG)  

###本地广播
本地广播机制发出的广播只能够在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播，以避免被其他应用程序截获或者接受到其他应用程序发送的垃圾广播  
通过LocalBroadcastManager()方法得到一个实，然后再注册广播接收器的时候调用LocalBroadcastManager的rehisterReceive()方法，在发送广播时调用sendBroadcast()  

        private LocalReceive localReceive;
    	private LocalBroadcastManager localBroadcastManager;


		public void onClick(View v){
                Intent intent= new Intent("com.example.broadcasttest.LOCAL_BROADCAST");
                localBroadcastManager.sendBroadcast(intent);
            }
        });
        interntFiler = new IntentFilter();
        interntFiler.addAction("com.example.broadcasttest.LOCAL_BROADCAST");
        localReceive = new LocalReceive();
        localBroadcastManager.registerReceiver(localReceive,interntFiler);
    }

运行程序  
![本地广播](/BroadcastTest/img/捕获5.PNG)
